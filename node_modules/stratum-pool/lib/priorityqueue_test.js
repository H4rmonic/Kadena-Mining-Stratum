const blockTemplate = require("./blockTemplate.js");
const FastPriorityQueue = require("fastpriorityqueue");
const u2 = require("util");
const reqfast = require("req-fast");
const https = require('https');

let chainBytes = [
  Buffer.from('01000000', 'hex'), 
  Buffer.from('02000000', 'hex'), 
  Buffer.from('03000000', 'hex'), 
  Buffer.from('04000000', 'hex'), 
  Buffer.from('05000000', 'hex'), 
  Buffer.from('06000000', 'hex'), 
  Buffer.from('07000000', 'hex'), 
  Buffer.from('08000000', 'hex'), 
  Buffer.from('09000000', 'hex'), 
  Buffer.from('10000000', 'hex'), 
]

const options = {
  hostname: "test.icemining.ca",
  //hostname: hostnames[nodeIndex],
  port: process.env.PORT,
  timeout: 1000,
  path: "/chainweb/0.0/mainnet01/mining/updates",
  method: "GET",
  headers: {
    "Content-Type": "application/json",
    "Content-Type": "application/octet-stream",
    "content-length": 4
  }
};

for (let i = 0; i < 10; i++) {
  const req = https.request(options, res => {
    console.log(`statusCode: ${res.statusCode}`);
    console.log(`headers: ${res.headers}`);

    if (res.statusCode != 200) {
      return;
    }
    res.on("data", d => {
      console.log(`chainId ${i}: ${d}`);
      
    });
  });
  req.on("error", error => {
    console.log(error);
    // MARK: How to auto-reconnect this (it should match the right node index)
  });
  req.write(chainBytes[i]);
}

/*
var reverseddefaultcomparator = function(a, b) {
  return a > b;
};
this.jobs = new FastPriorityQueue(reverseddefaultcomparator);
this.topK = [];

this.randomCounter = 0;
const k = 3; // upper limit -- actual k will be min(k, jobs.size)
let _this = this;

let rpcData = "2";
let nodeId = "mtl";
let tmpBlockTemplate1 = new blockTemplate(1, rpcData, nodeId);
addJob(tmpBlockTemplate1, k);

rpcData = "1";
let tmpBlockTemplate2 = new blockTemplate(2, rpcData, nodeId);
addJob(tmpBlockTemplate2, k);

rpcData = "4";
let tmpBlockTemplate3 = new blockTemplate(3, rpcData, nodeId);
addJob(tmpBlockTemplate3, k);

rpcData = "3";
nodeId = "de";
let tmpBlockTemplate4 = new blockTemplate(4, rpcData, nodeId);
addJob(tmpBlockTemplate4, k);

rpcData = "5";
nodeId = "de";
let tmpBlockTemplate5 = new blockTemplate(5, rpcData, nodeId);
addJob(tmpBlockTemplate5, k);

// fast top-k by comparator query
function addJob(job, k) {
  if (_this.jobs.size < k) {
    _this.jobs.add(job);
  } else {
    if (job < _this.jobs.peek()) {
      _this.jobs.replaceTop(job);
    }
  }
  _this.topK = _this.jobs.array.slice(0, k).sort(function(a, b) {
    return a - b;
  });
}

console.log(`Top-K elements added. Actual order of _this.jobs priqueue:`);
_this.jobs.forEach((val, idx) => {
  console.log(`${val.difficulty}`);
});


// _this.jobs.forEach((val, idx) => {
//   console.log(`${val.difficulty}`);
// });

// fake clients
console.log(`giving jobs to 7 fake miners`);
for (let i = 0; i < 7; i++) {
  const job = getNextAvailableJob();
  console.log(`job: diff ${job.difficulty} chainId ${job.chainId}`);
}

console.log(`deleting job with diff 30`);
deleteJob(tmpBlockTemplate4);

function getNextAvailableJob() {
    console.log(
      `counter is ${_this.randomCounter} _this.topK.size is ${_this.topK.length}`
    );
  console.log(u2.inspect(_this.topK));
  let job = _this.topK[_this.randomCounter];
  _this.randomCounter = (_this.randomCounter + 1) % _this.topK.length;
  return job;
}

function deleteJob(job) {
  _this.jobs.remove(job);
  _this.topK = _this.jobs.array
    .slice(0, Math.min(k, _this.jobs.size))
    .sort(function(a, b) {
      return a - b;
    });
}

function getJobByChainId(chainId) {
  for (let i = 0; i < _this.topK.length; i++) {
    let job = _this.topK[i];
    if (job !== null && job.chainId == chainId) return job;
  }
  return null;
}

console.log(
  `sorted top-K difficulties for k = ${k} (actual job size is ${_this.jobs.size})`
);
_this.topK.forEach(elem => console.log(`${elem.difficulty}`));

console.log(`giving jobs to 4 fake miners`);
for (let i = 0; i < 4; i++) {
  const job = getNextAvailableJob();
  console.log(`job: diff ${job.difficulty} chainId ${job.chainId}`);
}

console.log(`delete job by chainId 1`);
let job = getJobByChainId(1);
deleteJob(job);

console.log(`giving jobs to 6 fake miners`);
for (let i = 0; i < 6; i++) {
  const job = getNextAvailableJob();
  console.log(`job: diff ${job.difficulty} chainId ${job.chainId}`);
}

console.log(`add job chainid 6 diff 15`);
rpcData = "15";
nodeId = "mtl";
let tmpBlockTemplate = new blockTemplate(1, rpcData, nodeId);
addJob(tmpBlockTemplate, k);

console.log(`giving jobs to 3 fake miners`);
for (let i = 0; i < 3; i++) {
  const job = getNextAvailableJob();
  console.log(`job: diff ${job.difficulty} chainId ${job.chainId}`);
}
*/
