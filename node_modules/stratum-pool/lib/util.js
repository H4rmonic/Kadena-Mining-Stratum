var crypto = require('crypto');
var base58 = require('base58-native');
//var bignum = require('bignum');
var u2 = require('util');
//var shajs = require('sha.js')
//var sjcl = require('sjcl');
var forge = require('node-forge');
const chalk = require('stratum-pool/node_modules/chalk');

// diff = (2 ^ 128 - 1) / target

//const HSPACE = BigInt('0x10000000000000000000000000000000000000000000000000000000000000000');
const MAX_U256 = BigInt('0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff');
//const MAX_U128 = BigInt("0xffffffffffffffffffffffffffffffff");
//MAX_U256 = MAX_U256.add(1);


exports.base64toHEX = function (base64) {
    var raw = atob(base64);

    var HEX = "";

    for (i = 0; i < raw.length; i++) {
        var _hex = raw.charCodeAt(i).toString(16);

        HEX += _hex.length == 2 ? _hex : "0" + _hex;
    }
    return HEX.toUpperCase();
}


exports.getMinerReward = function (height) {
    let chains = 10;
    if (height >= 852054) chains = 20;
    if (height < 87600) return 23.04523 / chains;
    else if (height < 175200) return 22.97878 / chains;
    else if (height < 262800) return 22.91249 / chains;
    else if (height < 350400) return 22.84644 / chains;
    else if (height < 438000) return 22.78052 / chains;
    else if (height < 525600) return 22.71485 / chains;
    else if (height < 613200) return 22.64932 / chains;
    else if (height < 700800) return 22.58402 / chains;
    else if (height < 788400) return 22.51887 / chains;
    else if (height < 876000) return 22.45395 / chains;
    else if (height < 963600) return 22.38917 / chains;
    else if (height < 1051200) return 22.32462 / chains;
    else if (height < 1138800) return 22.26022 / chains;
    else if (height < 1226400) return 22.19604 / chains;
    else if (height < 1314000) return 22.13201 / chains;
    else if (height < 1401600) return 22.0682 / chains;
    else if (height < 1489200) return 22.00454 / chains;
    else if (height < 1576800) return 21.8778 / chains;
    else if (height < 1752000) return 21.81473 / chains;
    else
        return 0;
}

// diff = (2 ^ 128 - 1) / target
exports.target_to_diff = function (target) {
    return target < 1 ? MAX_U256 : (MAX_U256 + 1n) / target;
}

// diff = (2 ^ 128 - 1) / target
exports.diff_to_target = function (diff) {
    return diff < 1 ? MAX_U256 : (MAX_U256 + 1n) / diff;
}

exports.toLeftPaddedHexString = function (num, len) {
    str = num.toString(16);
    return num.toString(16).padStart(len, "0")
}

exports.toRightPaddedHexString = function (num, len) {
    str = num.toString(16);
    //return "0".repeat(len - str.length) + str;
    return num.toString(16).padEnd(len, "0")
}

// 286b header
exports.getNonce = function (powHeader) {
    return exports.reverseHex(rpc.substring(0, 16))
}

/**
 * Returns BigInt
 */
exports.getTarget = function (rpcData) {
    return BigInt("0x" + rpcData.substring(8, 72));
}
exports.getChainId = function (rpcData) {
    let chainBytes = exports.reverseHex(rpcData.substring(0, 8));
    let chainId = parseInt(Number("0x" + chainBytes), 10);
    //console.log(chalk.red("getChainId parse chainBytes " + chainBytes + " parsed chainId " + chainId));
    return chainId;
}

exports.getChainBytes = function (rpcData) {
    return exports.reverseHex(rpcData.substring(0, 8));
}

exports.getHeight = function (rpcData) {
    return parseInt(exports.reverseHex(rpcData.substring(588, 604)), 16);
};




/**
 * returns without 0x
 */
exports.removeLeadingZeros = function (hexString) {
    hexString = hexString.replace("0x", "");
    //console.log(`hextString:${hexString}`);

    let ret = hexString.replace(/^0+/, "");
    // console.log("hexString:" + hexString + " ret:" + ret);

    if (!ret) return "0";

    return ret;
}



/**
 * @param {string} hexString The hexString with or without 0x
 */
exports.padLeftHexString = function (hexString, len) {
    //if (typeof hexString == 'number') {
    //    hexString = hexString.toString(16);
    //    console.log("new nexString is:" + hexString);
    //}
    hexString = hexString.replace('0x', '');
    //console.log("TEST:" + hexString.padStart(len, "0"))
    return hexString.padStart(len, "0")
}

/**
 * @param {string} hexString The hexString with or without 0
 * x
 */
exports.padRightHexString = function (hexString, len) {
    hexString = hexString.replace('0x', '');
    return hexString.padEnd(len, "0")
}


/*
* The "compact" format is a representation of a whole
* number N using an unsigned 32bit number similar to a
* floating point format.
* The most significant 8 bits are the unsigned exponent of base 256.
* This exponent can be thought of as "number of bytes of N".
* The lower 24 bits are the mantissa.
* N = mantissa * 256^(exponent-3)
*/
// Compact should be a bignum base16
/*
exports.compact_to_target = function(compact) {
    let exponent = compact.shiftRight(24);
		let mantissa = compact.and(bignum('00ffffff', 16));

    let ret;
    if (exponent <= 3) {
			  let test = ((3-exponent) << 3);
        mantissa = mantissa.shiftRight(test)
        return mantissa;
    } else {
				ret = mantissa.shiftLeft(((exponent - 3) << 3));
    }

   /// later let overflow = (mantissa != 0) && (exponent > 32);
   return ret;
}
*/
// Accepts a u32 returns a u256
exports.compact_to_diff = function (compact) {
    let target = compact_to_target(compact);
    if (!target || target == 0) { // todo check overflow
        return 0;
    }
    return target_to_diff(target)
}

exports.addressFromEx = function (exAddress, ripdm160Key) {
    try {
        var versionByte = exports.getVersionByte(exAddress);
        var addrBase = Buffer.concat([versionByte, new Buffer(ripdm160Key, 'hex')]);
        var checksum = exports.sha256d(addrBase).slice(0, 4);
        var address = Buffer.concat([addrBase, checksum]);
        return base58.encode(address);
    }
    catch (e) {
        return null;
    }
};


exports.getVersionByte = function (addr) {
    var versionByte = base58.decode(addr).slice(0, 1);
    return versionByte;
};

exports.sha256 = function (buffer) {
    /*  const md = forge.md.sha256.create();
      md.update(buffer);
      return Buffer.from(md.digest().toHex());
    */
	/*	
    console.log("sha256(" + buffer.toString('hex')); 
    var md = forge.md.sha256.create();
    md.update(buffer);
    let test = md.digest().bytes();
   let nodeBuf = this.reverseBuffer(Buffer.from(test, 'binary'));

    console.log("hex1 is: " + u2.inspect(nodeBuf.toString('hex')) + " hex1 type:" + typeof test);
    return nodeBuf;
*/
    var hash1 = crypto.createHash('sha256');
    hash1.update(buffer)
    return hash1.digest();
    //console.log("sjcl hash:" + hash + " crypto hash:" + digest.toString('hex')); 
}

/*
exports.sha256 = function(buffer){
    var hash1 = crypto.createHash('sha256');
    hash1.update(buffer);
//console.log("hash1.digest=" + u2.inspect(hash1.digest()));
	return hash1.digest();
};
*/

/*
exports.sha256d = function(buffer) {
    console.log("sha256d: " + buffer.toString('hex') + "\n");
    var md = forge.md.sha256.create();
    md.update(buffer);
    let hex1 = md.digest().toHex();
    let bytes = forge.util.hexToBytes(hex1);

      console.log("digest1=" + digest1.toString('hex') + "\n");
    // 2nd round
    let md2 = forge.md.sha256.create();
    md.update(digest1);
    let digest2 = Buffer.from(md.digest()); 	
      console.log("digest2=" + digest2.toString('hex') + "\n");
return Buffer.from(digest2.toString('hex'));
    
}
*/
exports.sha256d = function (buffer) {
    return exports.sha256(exports.sha256(buffer)).reverse();
};

exports.reverseBuffer = function (buff) {
    var reversed = new Buffer(buff.length);
    for (var i = buff.length - 1; i >= 0; i--)
        reversed[buff.length - i - 1] = buff[i];
    return reversed;
};

exports.reverseHex = function (hex) {
    hex = hex.replace("0x", "");
    let b = Buffer.from(hex, 'hex');
    b = exports.reverseBuffer(b);
    return b.toString('hex')
};



exports.uint256BufferFromHash = function (hex) {

    var fromHex = new Buffer(hex, 'hex');

    if (fromHex.length != 32) {
        var empty = new Buffer(32);
        empty.fill(0);
        fromHex.copy(empty);
        fromHex = empty;
    }

    return exports.reverseBuffer(fromHex);
};

// TODO
exports.bufferToBE = function (hexString) {
    return hexString.bswap16();
}


/*
"serialized CScript" formatting as defined here:
 https://github.com/bitcoin/bips/blob/master/bip-0034.mediawiki#specification
Used to format height and date when putting into script signature:
 https://en.bitcoin.it/wiki/Script
 */
exports.serializeNumber = function (n) {

    /* Old version that is bugged
    if (n < 0xfd){
        var buff = new Buffer(2);
        buff[0] = 0x1;
        buff.writeUInt8(n, 1);
        return buff;
    }
    else if (n <= 0xffff){
        var buff = new Buffer(4);
        buff[0] = 0x3;
        buff.writeUInt16LE(n, 1);
        return buff;
    }
    else if (n <= 0xffffffff){
        var buff = new Buffer(5);
        buff[0] = 0x4;
        buff.writeUInt32LE(n, 1);
        return buff;
    }
    else{
        return Buffer.concat([new Buffer([0x9]), binpack.packUInt64(n, 'little')]);
    }*/

    //New version from TheSeven
    if (n >= 1 && n <= 16) return new Buffer([0x50 + n]);
    var l = 1;
    var buff = new Buffer(9);
    while (n > 0x7f) {
        buff.writeUInt8(n & 0xff, l++);
        n >>= 8;
    }
    buff.writeUInt8(l, 0);
    buff.writeUInt8(n, l++);
    return buff.slice(0, l);

};


exports.getSafeString = function (s) {
    if (!s || s.length == 0) return null;
    return s.toString().replace(/[^a-zA-Z0-9.+_@!#$%&*=()/]+/g, '');
}


exports.getSafeWorkerString = function (raw) {
    if (!raw) return "noname";
    var s = exports.getSafeString(raw).split(".");
    var addr = s[0];
    var wname = "noname";
    if (s.length > 1)
        wname = s[1];
    return addr + "." + wname;
}


/*
Used for serializing strings used in script signature
 */
exports.serializeString = function (s) {
    if (s.length < 253)
        return Buffer.concat([
            new Buffer([s.length]),
            new Buffer(s)
        ]);
    else if (s.length < 0x10000)
        return Buffer.concat([
            new Buffer([253]),
            exports.packUInt16LE(s.length),
            new Buffer(s)
        ]);
    else if (s.length < 0x100000000)
        return Buffer.concat([
            new Buffer([254]),
            exports.packUInt32LE(s.length),
            new Buffer(s)
        ]);
    else
        return Buffer.concat([
            new Buffer([255]),
            exports.packUInt16LE(s.length),
            new Buffer(s)
        ]);
};
// Fast but assumes 4 byte int only
exports.reverseEndian = function (x) {
    buf = Buffer.allocUnsafe(4)
    buf.writeUIntLE(x, 0, 4)
    return buf.readUIntBE(0, 4)
}


/**
 * hexString is a string. Returns a hex string buffer
 * @param { hexString The hexString with or without 0x
 */
exports.hexToUInt32LE = function (hexString) {
    hexString = hexString.replace('0x', '');
    let r = parseInt('0x' + hexString.match(/../g).reverse().join(''));
    return r.toString(16);
}

exports.packUInt16LE = function (num) {
    var buff = new Buffer(2);
    buff.writeUInt16LE(num, 0);
    return buff;
};
exports.packInt32LE = function (num) {
    var buff = new Buffer(4);
    buff.writeInt32LE(num, 0);
    return buff;
};
exports.packInt32BE = function (num) {
    var buff = new Buffer(4);
    buff.writeInt32BE(num, 0);
    return buff;
};
exports.packUInt32LE = function (num) {
    var buff = new Buffer(4);
    buff.writeUInt32LE(num, 0);
    return buff;
};
exports.packUInt32BE = function (num) {
    var buff = new Buffer(4);
    buff.writeUInt32BE(num, 0);
    return buff;
};
exports.packInt64LE = function (num) {
    var buff = new Buffer(8);
    buff.writeUInt32LE(num % Math.pow(2, 32), 0);
    buff.writeUInt32LE(Math.floor(num / Math.pow(2, 32)), 4);
    return buff;
};


/*
An exact copy of python's range feature. Written by Tadeck:
 http://stackoverflow.com/a/8273091
 */
exports.range = function (start, stop, step) {
    if (typeof stop === 'undefined') {
        stop = start;
        start = 0;
    }
    if (typeof step === 'undefined') {
        step = 1;
    }
    if ((step > 0 && start >= stop) || (step < 0 && start <= stop)) {
        return [];
    }
    var result = [];
    for (var i = start; step > 0 ? i < stop : i > stop; i += step) {
        result.push(i);
    }
    return result;
};




/*
 For POS coins - used to format wallet address for use in generation transaction's output
 */
exports.pubkeyToScript = function (key) {
    if (key.length !== 66) {
        console.error('Invalid pubkey: ' + key);
        throw new Error();
    }
    var pubkey = new Buffer(35);
    pubkey[0] = 0x21;
    pubkey[34] = 0xac;
    new Buffer(key, 'hex').copy(pubkey, 1);
    return pubkey;
};


exports.miningKeyToScript = function (key) {
    var keyBuffer = new Buffer(key, 'hex');
    return Buffer.concat([new Buffer([0x76, 0xa9, 0x14]), keyBuffer, new Buffer([0x88, 0xac])]);
};

/*
For POW coins - used to format wallet address for use in generation transaction's output
 */
exports.addressToScript = function (addr) {

    var decoded = base58.decode(addr);

    if (decoded.length != 25) {
        console.error('invalid address length for ' + addr);
        throw new Error();
    }

    if (!decoded) {
        console.error('base58 decode failed for ' + addr);
        throw new Error();
    }

    var pubkey = decoded.slice(1, -4);

    return Buffer.concat([new Buffer([0x76, 0xa9, 0x14]), pubkey, new Buffer([0x88, 0xac])]);
};


exports.getReadableHashRateString = function (hashrate) {
    var i = -1;
    var byteUnits = [' KH', ' MH', ' GH', ' TH', ' PH'];
    do {
        hashrate = hashrate / 1024;
        i++;
    } while (hashrate > 1024);
    return hashrate.toFixed(2) + byteUnits[i];
};




//Creates a non-truncated max difficulty (diff1) by bitwise right-shifting the max value of a uint256
exports.shiftMax256Right = function (shiftRight) {

    //Max value uint256 (an array of ones representing 256 enabled bits)
    var arr256 = Array.apply(null, new Array(256)).map(Number.prototype.valueOf, 1);

    //An array of zero bits for how far the max uint256 is shifted right
    var arrLeft = Array.apply(null, new Array(shiftRight)).map(Number.prototype.valueOf, 0);

    //Add zero bits to uint256 and remove the bits shifted out
    arr256 = arrLeft.concat(arr256).slice(0, 256);

    //An array of bytes to convert the bits to, 8 bits in a byte so length will be 32
    var octets = [];

    for (var i = 0; i < 32; i++) {

        octets[i] = 0;

        //The 8 bits for this byte
        var bits = arr256.slice(i * 8, i * 8 + 8);

        //Bit math to add the bits into a byte
        for (var f = 0; f < bits.length; f++) {
            var multiplier = Math.pow(2, f);
            octets[i] += bits[f] * multiplier;
        }

    }

    return new Buffer(octets);
};


exports.bufferToCompactBits = function (startingBuff) {
    var bigNum = bignum.fromBuffer(startingBuff);
    var buff = bigNum.toBuffer();

    buff = buff.readUInt8(0) > 0x7f ? Buffer.concat([new Buffer([0x00]), buff]) : buff;

    buff = Buffer.concat([new Buffer([buff.length]), buff]);
    var compact = buff.slice(0, 4);
    return compact;
};

/*
exports.diffToTarget = function(diff) {
let diff1 = Buffer.from('0x00000000ffff0000000000000000000000000000000000000000000000000000', 'hex');
//	let diff1 = Buffer.from('ffff00000000', 'hex');
  let diff1BigNum = bignum.fromBuffer(diff1);
  let t = bignum(diff1BigNum).div(diff);
  let tgtBuf = t.toBuffer();
  return Buffer.from('000000001fffffffffffffffffffffffffffffffffffffffffffffffffffffff', 'hex');
//return tgtBuf;
}
*/

/*
 Used to convert getblocktemplate bits field into target if target is not included.
 More info: https://en.bitcoin.it/wiki/Target
 */

exports.bignumFromBitsBuffer = function (bitsBuff) {
    var numBytes = bitsBuff.readUInt8(0);
    var bigBits = bignum.fromBuffer(bitsBuff.slice(1));
    var target = bigBits.mul(
        bignum(2).pow(
            bignum(8).mul(
                numBytes - 3
            )
        )
    );
    return target;
};

exports.bignumFromBitsHex = function (bitsString) {
    var bitsBuff = new Buffer(bitsString, 'hex');
    return exports.bignumFromBitsBuffer(bitsBuff);
};

exports.convertBitsToBuff = function (bitsBuff) {
    var target = exports.bignumFromBitsBuffer(bitsBuff);
    var resultBuff = target.toBuffer();
    var buff256 = new Buffer(32);
    buff256.fill(0);
    resultBuff.copy(buff256, buff256.length - resultBuff.length);
    return buff256;
};

exports.getTruncatedDiff = function (shift) {
    return exports.convertBitsToBuff(exports.bufferToCompactBits(exports.shiftMax256Right(shift)));
};
