var path = require('path');
//var rel = path.relative(process.cwd(), __dirname);
//var alljs = path.join(rel, 'node_modules/stratum-pool/lib/', 'stratum.js');
//var njstrace = require('njstrace').inject({files: [alljs]});
var net = require('net');
var events = require('events');
var chalk = require('chalk');

var PROTECTION_MODE = 'relaxed'; // "strict | relaxed"

var jobManager = require('./jobManager.js');

var util = require('./util.js');
var u2 = require('util');
this.malformed = {};

var NoncePrefixCounter = function () {
  var count = 0;
  //var padding = '';//'deadbeefcafebabe';
  return {
    next: function () {
      count++;
      if (Number.MAX_VALUE === count) count = 0;
      //return util.toLeftPaddedHexString(count, 8);
      //return padding + util.packInt32LE(count).toString('hex');
      //let packedBits = util.packInt16LE(count).toString("hex");
      //good console.log(`noncePrefix count ${count} is ${util.toLeftPaddedHexString(count, 6)}`);
      return util.toLeftPaddedHexString(count.toString(16), 4);
    },
  };
};

/**
 * Defining each client that connects to the stratum server.
 * Emits:
 *  - subscription(obj, cback(error, extraNonce2Size))
 *  - submit(data(name, jobID, extraNonce2, ntime, nonce))
 **/
var StratumClient = function (options) {
  this.lastTimeStamp = +Date() / 1000;
  this.lastvalid = 0;

  //this.sentJobs = [];

  var pendingDifficulty = null;
  var difficulty = null;
  //private members
  this.noncePrefix = options.noncePrefix;
  this.mode = 0; // normal
  this.party_pass = "";
  this.socket = options.socket;
  this.ports = options.ports;
  this.jobParams = options.jobParams;
  this.remoteAddress = options.socket.remoteAddress;
  this.chainId = null;

  var banning = options.banning;
  var _this = this;

  this.lastActivity = Date.now();
  this.shares = { valid: 0, invalid: 0 };

  this.invalidMessages = 0;

  var considerBan =
    !banning || !banning.enabled
      ? function () {
        return false;
      }
      : function (shareValid) {
        if (shareValid === true) _this.shares.valid++;
        else _this.shares.invalid++;
        var totalShares = _this.shares.valid + _this.shares.invalid;
        if (totalShares >= banning.checkThreshold) {
          var percentBad = (_this.shares.invalid / totalShares) * 100;
          if (percentBad < banning.invalidPercent)
            //reset shares
            this.shares = { valid: 0, invalid: 0 };
          else {
            _this.emit('triggerBan', _this.shares.invalid + ' out of the last ' + totalShares + ' shares were invalid');
            _this.socket.destroy();
            return true;
            //return false;
          }
        }
        return false;
      };

  this.init = function init() {
    setupSocket();
  };

  function handleMessage(message) {
    switch (message.method) {
      case 'mining.subscribe':
        handleSubscribe(message); // params
        break;
      case 'mining.authorize':
        handleAuthorize(message, true);
        break;
      case 'mining.submit':
        _this.lastActivity = Date.now();
        handleSubmit(message);
        break;
      case 'mining.get_transactions':
        sendJson({
          id: null,
          result: [],
          error: true,
        });
        break;
      default:
        _this.emit('unknownStratumMethod', message);
        break;
    }
  }

  /*
DEBU[2019-10-30T12:44:49-03:00] write to pool: {"id":0,"method":"mining.subscribe","params":["ckbminer-v1.0.0",null]}
DEBU[2019-10-30T12:44:50-03:00] recv from pool: {"id":0,"result":[null,"3201b743",12],"error":null}
*/
  function handleSubscribe(message) {
    //console.log("handleSubscribe();" + JSON.stringify(message));
    if (!_this._authorized) {
      _this.requestedSubscriptionBeforeAuth = true;
    }
    _this.minerVersion = message.params[0];

    //console.log("handleSubscribe. message=\n" + JSON.stringify(message) + "_this=" + JSON.stringify(_this));
    _this.emit('subscription', {}, function (error, data) {
      if (error) {
        console.log('subscription error');
        sendJson({
          id: message.id,
          result: null,
          error: error,
        });
        return;
      }
      const noncePrefixPadded = util.toLeftPaddedHexString(_this.noncePrefix.toString(16), 4);
      //console.log(`noncePrefixPadded ${noncePrefixPadded}`)

      const replyJson = {
        id: message.id,
        result: [null, noncePrefixPadded, 6], // 8 - 5 = 3 noncePrefix Bytes
        error: null,
      };
      //console.log(">Client:" + JSON.stringify(replyJson));
      sendJson(replyJson);
    });
  }

  /*
DEBU[2019-10-30T12:44:50-03:00] write to pool: {"id":0,"method":"mining.authorize","params":["test.worker1","x"]}
DEBU[2019-10-30T12:44:50-03:00] recv from pool: {"id":0,"result":true,"error":null}
*/
  function handleAuthorize(message, replyToSocket) {
    //console.log('handleAuthorize: ' + JSON.stringify(message));

    if (!message.params || !message.params[0]) {
      //_this.emit('malformedMessage', message);
      return socket.destroy();
    }

    _this.workerName = util.getSafeWorkerString(message.params[0]);
    _this.workerPass = util.getSafeString(message.params[1]);

    //console.log("worker Pass is " + _this.workerPass);

    options.authorizeFn(_this.remoteAddress, _this.minerVersion, options.socket.localPort, _this.workerName, _this.workerPass, function (result) {
      _this.authorized = !result.error && result.authorized;

      // console.log("authorizeFn result is " + JSON.stringify(result));

      if (replyToSocket) {
        let replyJson = {
          id: message.id,
          result: _this.authorized,
          error: null,
        };
        //console.log("ReplyJson:" + JSON.stringify(replyJson));
        sendJson(replyJson);
      }

      if (!_this.authorized) {
        //console.log(chalk.red(`Not authorized`));
        return;
      }

      _this.iceWorkerId = result.iceWorkerId;
      _this.mode = result.mode;
      _this.party_pass = result.party_pass;
      _this.difficulty = result.difficulty; // Did the user set a starting diff in password -p d=XXX ?
      _this.iceUserId = result.iceUserId;
      _this.iceCoinId = result.iceCoinId;

      //console.log("stratum.js mode " + _this.mode + " party pass is " + _this.party_pass);

      if (result.difficulty) {
        console.log('****** user set difficulty via password -d=' + result.difficulty + ' this.diff:' + _this.difficulty);

        var result = _this.sendDifficulty(result.difficulty);
        //pendingDifficulty = null;
        if (result) {
          _this.emit('difficultyChanged', _this.difficulty);
        } else {
          console.log("user didn't set diff in password");
        }
        //return;
      }

      // User didn't set difficulty,
      /*
      if (_this.minerVersion.includes('NiceHash/')) {
              switch (options.coin.algorithm) {
              case 'x16r':
                  console.log(`{$_this.minerVersion} x16r sending diff 1024`);
                  this.sendDifficulty(1024);
                  break;
              case 'equihash':
                  console.log(`{$_this.minerVersion} equihash (zhash) sending diff 2 (xxxx)`);
                  this.sendDifficulty(2);
                  break;
              default:
                  console.log(`WARNING {$_this.minerVersion} UNKNOWN ALGO sending diff 1024`);
                  this.sendDifficulty(1024);
              }
          return;
      }*/

      // Send a random valid mining job right away
      //console.log("user did not set diff, getting coin default");
      if (typeof _this.ports[options.socket.localPort] !== 'undefined' && _this.ports[options.socket.localPort].diff) {
        //console.log("set coin default diff: " + _this.ports[options.socket.localPort].diff);
        const diff = _this.ports[options.socket.localPort].diff;
        const BigIntDiff = BigInt(diff);
        // const tgtHex = "0x" + util.diff_to_target(BigIntDiff).toString(16);
	const tgtHex = "0000000000ffffffffffffffffffffffffffffffffffffffffffffffffffffff";
	const targetPadded = util.padLeftHexString(tgtHex, 64);
        console.log(`Starting Difficulty ${BigIntDiff} / ${targetPadded}`);
	      
	var result = _this.sendDifficulty(diff);
        _this.difficulty = diff;
        _this.emit('difficultyChanged', _this.difficulty);
        // if (!_this) {
        //   console.log(chalk.red(`NO CLIENT STRATUM LINE 255`));
        // }
        _this.emit('clientReady', _this);
      }
    });
  }

  function handleSubmit(message) {
    if (!message.params) {
	    console.log("handleSubmit but no params -- destroying socket!");
      _this.emit('malformedMessage', message);
      return socket.destroy();
    }

    if (!_this.authorized) {
      sendJson({
        id: message.id,
        result: null,
        error: [24, 'unauthorized worker', null],
      });
      considerBan(false);
      return;
    }
    /*
        if (!_this.extraNonce1){
            sendJson({
                id    : message.id,
                result: null,
                error : [25, "not subscribed", null]
            });
            considerBan(false);
            return;
        }*/
    // console.log("***** about to emit submit. message:" + JSON.stringify(message));

    // TODO: handle GPU method without extraNonce:
    if (message.params[3]) {
      console.log("mining.submit contains extraNonce");
    }

    _this.emit(
      'submit',
      {
        name: message.params[0],
        jobId: message.params[1],
        nonce: message.params[2],
        extraNonce: message.params[3],
      },
      function (error, result) {
        //console.log("error:" + JSON.stringify(error));
        if (!considerBan(result)) {
          const retJson = {
            id: message.id,
            result: result ? result : false,
            error: error,
          };
          //console.log(">Miner: " + JSON.stringify(retJson));
          sendJson(retJson);
        }
      },
    );

    // _this.emit(
    //   'submit',
    //   {
    //     name: message.params[0],
    //     jobId: message.params[1],
    //     nonce: message.params[2],
    //   },
    //   function (error, result) {
    //     //console.log("error:" + JSON.stringify(error));
    //     if (!considerBan(result)) {
    //       const retJson = {
    //         id: message.id,
    //         result: result ? result : false,
    //         error: error,
    //       };
    //       //console.log("sending to miner: " + JSON.stringify(retJson));
    //       sendJson(retJson);
    //     }
    //   },
    // );
  }

  function sendJson() {
    var response = '';
    for (var i = 0; i < arguments.length; i++) {
      response += JSON.stringify(arguments[i]) + '\n';
    }
    options.socket.write(response);
  }

  function setupSocket() {
    var socket = options.socket;
    var dataBuffer = '';
    socket.setEncoding('utf8');

    if (options.tcpProxyProtocol === true) {
      socket.once('data', function (d) {
        if (d.indexOf('PROXY') === 0) {
          _this.remoteAddress = d.split(' ')[2];
        } else {
          _this.emit('tcpProxyError', d);
        }
        _this.emit('checkBan');
      });
    } else {
      _this.emit('checkBan');
    }
    socket.on('data', function (d) {
      dataBuffer += d;

      // Dynamic Banning
      if (Buffer.byteLength(dataBuffer, 'utf8') > 10240) {
        //10KB
        dataBuffer = '';
        _this.emit('socketFlooded');
        let ip = this.remoteAddress.replace('::ffff:', '');
        banIP(ip);
        socket.destroy();
        return;
      }

      if (dataBuffer.indexOf('\n') !== -1) {
        var messages = dataBuffer.split('\n');
        var incomplete = dataBuffer.slice(-1) === '\n' ? '' : messages.pop();
        messages.forEach(function (message) {
          if (message === '') return;
          var messageJson;
          try {
            messageJson = JSON.parse(message);
          } catch (e) {
            if (options.tcpProxyProtocol !== true || d.indexOf('PROXY') !== 0) {
              // _this.emit('malformedMessage', message);
              //_this.invalidMessages++;

              let ip = _this.remoteAddress.replace('::ffff:', '');
              console.log(`Malformed Message ${message} from ${ip}`);
	      // global.Sentry.captureMessage(`Malformed Message from ${ip}`);

              //console.log(`this is ${u2.inspect(_this)}`);
              //console.log(
              //  chalk.red(
              //    `PROTECTION NODE ${PROTECTION_MODE} invalid: ${_this.invalidMessages}`
              //  )
              //);
              socket.destroy();

              // switch (PROTECTION_MODE) {
              // case 'strict':
              //_this.banIP(ip);
              // socket.destroy();
              // break;
              // case 'relaxed':
              // console.log(chalk.yellow(`Anti-DDOS (${PROTECTION_MODE}) Invalid Count ${_this.invalidMessages} from ip ${_this.remoteAddress}`));

              //const count = _this.malformed[_this.remoteAddress] + 1;

              //_this.malformed[_this.remoteAddress] += 1;
              // console.log(chalk.red(`_this.malformed ${u2.inspect(_this.malformed)} count ${count}`));

              //_this.malformed[_this.remoteAddress] + 1;
              // if (_this.invalidMessages > 50) {
              //   console.log(
              //     chalk.red(`Anti-DDOS (${PROTECTION_MODE}) Invalid Count ${_this.invalidMessages} from ip ${_this.remoteAddress} -- PERM BANNED!!`),
              //   );
              //   global.Sentry.captureMessage(`Anti-DDOS (didnt ban) ${_this.remoteAddress} Malformed Message: ${message}`);
              //   //_this.banIP(ip);
              //   socket.destroy();
              //   break;
              // }
              // }
              //considerBan(false);
            }
            return;
          }

          if (messageJson) {
            handleMessage(messageJson);
          }
        });
        dataBuffer = incomplete;
      }
    });
    socket.on('close', function () {
      _this.emit('socketDisconnect', _this.iceWorkerId);
    });
    socket.on('error', function (err) {
      if (err.code !== 'ECONNRESET') _this.emit('socketError', err);
    });
  }

  this.getLabel = function () {
    return (_this.workerName || '(unauthorized)') + ' [' + _this.remoteAddress + ']';
  };

  this.enqueueNextDifficulty = function (requestedNewDifficulty) {
    pendingDifficulty = requestedNewDifficulty;
    //console.log("***************** enqueueNextDiff:" + this.pendingDifficulty);
    return true;
  };

  //public members

  this.banIP = function (ip) {
    var exec = require('child_process').exec;
    console.log(chalk.red(`Banning malformed message`));
    exec(`/root/bin/bl ${ip}`, function callback(error, stdout, stderr) {
      if (error) {
        console.log(`error: ${error}`);
        global.Sentry.captureException(`KDA Banning Error: ${error}`);
      }
      if (stdout) {
        console.log(chalk.red(`PERM BAN FLOODER: ${stdout}`));
        console.log(`stdout: ${stdout}`);
      }
      if (stderr) {
        console.log(`stderr: ${stderr}`);
        global.Sentry.captureException(`KDA Banning Error: ${stderr}`);
      }
    });
  };

  /**
   * IF the given difficulty is valid and new it'll send it to the client.
   * returns boolean
   * recv from pool: {"id":0,"method":"mining.set_target","params":["0000000100000000000000000000000000000000000000000000000000000000"]}
   * Diffiiculty should be a BitInt
   **/
  this.sendDifficulty = function (difficulty) {
    difficulty = Math.floor(difficulty);
    //console.log("***********sendDifficulty() difficulty=" + difficulty);
    // todo
    if (difficulty === this.difficulty) {
      //console.log('difficulty == this.difficulty, retuning false');
      return false;
    }
    _this.previousDifficulty = _this.difficulty;
    _this.target = BigInt("0x" + difficulty);
    _this.difficulty = difficulty;

    const BigIntDiff = BigInt(difficulty);
    //const target = util.padLeftHexString(
    //  util.diff_to_target(BigIntDiff).toString(16),
    // 64
    //);

    const tgtPadded = "0000000000ffffffffffffffffffffffffffffffffffffffffffffffffffffff";
    //let diff = util.target_to_diff(target);
    //let tgtPadded = util.toLeftPaddedHexString(target.toString(16), 64);

    const retJson = {
      id: null,
      method: "mining.set_target",
      params: [tgtPadded] //[difficulty]//[512],
    };

    console.log(chalk.red(`SENDING ${JSON.stringify(retJson)}`));
    sendJson(retJson);
    return true;
  };

  // Assumes we know what we are doing
  this.sendMiningJob = function (blockTemplate) {
    if (!_this.authorized) {
      //console.log(chalk.red(`Not authorized`));
      return;
    }

    const jobParams = blockTemplate.getJobParams();

    if (jobParams[0] != blockTemplate.jobId) {
      console.log(chalk.red(`!!!!!!!!!!!!!! TEMPLATE JOB MISMATCH`));
    }

    var lastActivityAgo = Date.now() - _this.lastActivity;
    if (lastActivityAgo > options.connectionTimeout * 1000) {
      _this.emit('socketTimeout', 'last submitted a share was ' + ((lastActivityAgo / 1000) | 0) + ' seconds ago');
      _this.socket.destroy();
      return;
    }

    const json = {
      method: 'mining.notify',
      params: jobParams,
    };

    //console.log(">Client:" + JSON.stringify(json));
    //console.log(chalk.green(`sendMiningJob chain `) + chalk.gray(`${blockTemplate.chainId}:`) + chalk.yellow(`${blockTemplate.jobId}`));
    sendJson(json);

    if (pendingDifficulty !== null) {
      var result = _this.sendDifficulty(pendingDifficulty);
      pendingDifficulty = null;
      if (result) {
        _this.emit("difficultyChanged", _this.difficulty);
      }
    }
    //console.log(chalk.blue(`>>> sendMiningJob chain ${_this.chainId} job ${blockTemplate.jobId} jobParams.jobId ${jobParams[0]}`));
  };
};
StratumClient.prototype.__proto__ = events.EventEmitter.prototype;

/**
 * The actual stratum server.
 * It emits the following Events:
 *   - 'client.connected'(StratumClientInstance) - when a new miner connects
 *   - 'client.disconnected'(StratumClientInstance) - when a miner disconnects. Be aware that the socket cannot be used anymore.
 *   - 'started' - when the server is up and running
 **/
var StratumServer = (exports.Server = function StratumServer(options, authorizeFn) {
  //private members
  var bannedMS = options.banning ? options.banning.time * 1000 : null;

  var _this = this;
  var stratumClients = {};
  var noncePrefixCounter = NoncePrefixCounter();
  var rebroadcastTimeout;
  var bannedIPs = {};

  function checkBan(client) {
    if (options.banning && options.banning.enabled && client.remoteAddress in bannedIPs) {
      var bannedTime = bannedIPs[client.remoteAddress];
      var bannedTimeAgo = Date.now() - bannedTime;
      var timeLeft = bannedMS - bannedTimeAgo;
      if (timeLeft > 0) {
        client.socket.destroy();
        client.emit('kickedBannedIP', (timeLeft / 1000) | 0);
      } else {
        delete bannedIPs[client.remoteAddress];
        client.emit('forgaveBannedIP');
      }
    }
  }

  this.handleNewClient = function (socket) {
    socket.setKeepAlive(true);
    _this.noncePrefix = noncePrefixCounter.next();
    var client = new StratumClient({
      noncePrefix: _this.noncePrefix,
      authorizeFn: authorizeFn,
      socket: socket,
      banning: options.banning,
      connectionTimeout: options.connectionTimeout,
      tcpProxyProtocol: options.tcpProxyProtocol,
      ports: options.ports,
    });

    stratumClients[_this.noncePrefix] = client;
    //stratumClients[_this.noncePrefix].chainId = null;

    _this.emit('client.connected', client);
    client
      .on('socketDisconnect', function () {
        _this.removeStratumClientBySubId(client.noncePrefix);
        _this.emit('client.disconnected', client);
      })
      .on('checkBan', function () {
        checkBan(client);
      })
      .on('triggerBan', function () {
        console.log(chalk.red(`TRIGGER BAN`));
        _this.addBannedIP(client.remoteAddress);
      })
      .init();
    return _this.noncePrefix;
  };

  this.getSPS = function () {
    let spsTotal = 0;
    for (id in stratumClients) {
      var c = stratumClients[id];
      let now = +new Date() / 1000;
      let deltaT = now - c.lastTimeStamp;
      let deltaS = c.shares.valid - c.lastvalid;
      c.lastTimeStamp = now;
      let sps = Math.round(deltaS / deltaT);
      if (sps) spsTotal += sps;
      c.lastvalid = c.shares.valid;
      console.log('client sps: ' + sps);
    }
    console.log('total sps:' + spsTotal);
  };

  // TEST1: distribute evenly to all chains
  /*
this.broadcastMiningJobs = function(blockTemplate) {

   const jobLen = currentJob.length;
    const chunks = jobLen; // for now
    const keys = Object.keys(stratumClients);
    if (keys.length == 0) return;
    //const clientLen = Math.ceil(keys.length / jobLen);
    console.log(`keys ${keys}`);
    let chainId = 0;
    console.log(`dividing ${jobLen} jobs into ${chunks} chunks for ${keys.length} clients`);
    for (var i = 0; i < keys.length; i++) {
      console.log(`send chainId ${chainId} to client ${keys[i]}`);
      let c = stratumClients[keys[i]];
      chainId = (chainId + 1) % chunks
      //console.log(`client ${c.chainId}`);
      client.sendMiningJob(blockTemplate);
    }

  }
*/

  /**
   * Experimental equal distribution of all valid jobs
   */

  this.broadcastMiningJobs = function (chainId, jobManager) {
    //console.log(`broadcastMiningJobs()`);
    if (jobManager.currentJob.length == 0) {
      console.log(`no jobs to broadcast -- returning`);
    }
    // let chainId = blockTemplate.chainId;

    //console.log(`stratumClients: ${stratumClients}`);

    for (var clientId in stratumClients) {
      var client = stratumClients[clientId];

      if (client.chainId === null) {
        client.chainId = chainId;
        //console.log(`client.chainId was null. setting to ${client.chainId}`);
        const job = jobManager.getNextAvailableJob();
        if (job === null) {
          //console.log("broadcastMiningJobs... job null returning");
          return;
        }
        //console.log(`ok.. job is ${job}`);
        client.sendMiningJob(job);
        continue;
      }

      if (client.chainId == chainId) {
        //console.log(chalk.rgb(255, 0, 255)(`(BROADDCAST???) MATCHED CLIENT ON CHAIN ${client.chainId}`));
        let job = jobManager.getJobByChainId(chainId);
        if (!job) {
          //console.log(`CASE 1 no job?? getting next avail`);
          job = jobManager.getNextAvailableJob();
        }
        if (job === null) {
          //console.log(`CASE 2`);
          continue;
        }
        client.sendMiningJob(job);
      }
    }

    clearTimeout(rebroadcastTimeout);
    rebroadcastTimeout = setTimeout(function () {
      _this.emit('broadcastTimeout');
    }, options.jobRebroadcastTimeout * 1000);
  };

  (function init() {
    //Interval to look through bannedIPs for old bans and remove them in order to prevent a memory leak
    if (options.banning && options.banning.enabled) {
      setInterval(function () {
        for (ip in bannedIPs) {
          var banTime = bannedIPs[ip];
          if (Date.now() - banTime > options.banning.time) delete bannedIPs[ip];
        }
      }, 1000 * options.banning.purgeInterval);
    }

    //SetupBroadcasting();

    var serversStarted = 0;
    Object.keys(options.ports).forEach(function (port) {
      net
        .createServer({ allowHalfOpen: false }, function (socket) {
          _this.handleNewClient(socket);
        })
        .listen(parseInt(port), function () {
          serversStarted++;
          if (serversStarted == Object.keys(options.ports).length) _this.emit('started');
        });
    });
  })();

  //public members

  this.addBannedIP = function (ipAddress) {
    bannedIPs[ipAddress] = Date.now();
    /*for (var c in stratumClients){
            var client = stratumClients[c];
            if (client.remoteAddress === ipAddress){
                _this.emit('bootedBannedWorker');
            }
        }*/
  };

  this.getStratumClients = function () {
    return stratumClients;
  };

  this.removeStratumClientBySubId = function (subscriptionId) {
    delete stratumClients[subscriptionId];
  };

  /*
    this.manuallyAddStratumClient = function(clientObj) {
        var subId = _this.handleNewClient(clientObj.socket);
        if (subId != null) { // not banned!
            stratumClients[subId].manuallyAuthClient(clientObj.workerName, clientObj.workerPass);
            stratumClients[subId].manuallySetValues(clientObj);
        }
    };
*/

  //this.setJobParams = function(params) {
  //  _this.jobParams = params;
  //};

  this.getTotalMinerCount = function () {
    return Object.keys(stratumClients).length;
  };
});
StratumServer.prototype.__proto__ = events.EventEmitter.prototype;
