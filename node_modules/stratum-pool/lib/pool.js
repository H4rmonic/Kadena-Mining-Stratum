'use strict';
const reqfast = require('req-fast');

var events = require('events');
var async = require('async');
var varDiff = require('./varDiff.js');
//var daemon = require("./daemon.js");
var peer = require('./peer.js');
var stratum = require('./stratum.js');
var jobManager = require('./jobManager.js');
//var APIClient = require("./apiClient.js");
var util = require('./util.js');
var chalk = require('chalk');
var u2 = require('util');
var colors = require('colors');
var qs = require('querystring');

const http = require('http');
const https = require('https');

const diff1 = '0x00000000ffff0000000000000000000000000000000000000000000000000000';

const rp = require('request-promise');

const CHAINS = 20;

const request = require('request');
process.env['NODE_TLS_REJECT_UNAUTHORIZED'] = 0;
const nodes = [
  { hostname: process.env.NODE1, id: 'us', nodeIndex: 0 },
  // { hostname: process.env.NODE2, id: 'us', nodeIndex: 1 },
  // { hostname: process.env.NODE3, id: 'eu', nodeIndex: 2 },
  // { hostname: process.env.NODE1, id: 'mtl', nodeIndex: 0 },
  //  { hostname: process.env.NODE2, id: 'eu', nodeIndex: 1 },
  //  { hostname: process.env.NODE3, id: 'us-w3', nodeIndex: 2 },
  //  { hostname: process.env.NODE4, id: 'jp3', nodeIndex: 3 },
];

let cutPath = process.env.CUT;


// Mark: TODO -- only invalidate once per node!
let cutNodes = [
   `jp3.chainweb.com`,
   `fr1.chainweb.com`,
   `us-e1.chainweb.com`,
   `jp2.chainweb.com`,
   `us-e2.chainweb.com`,
   `us-e3.chainweb.com`,
   `us-w1.chainweb.com`,
   `us-w2.chainweb.com`,
   `jp1.chainweb.com`,
];

let cutCounter = 0;

var pool = (module.exports = function pool(options, authorizeFn) {
  this.lastTimeStamp = Math.round(+new Date() / 1000);
  //console.log('lastTimeStamp=' + this.lastTimeStamp);
  this.lastvalid = 0;

  this.options = options;
  var _this = this;
  var blockPollingIntervalId;

  //_this.hashes = [];

  var emitLog = function (text) {
    _this.emit('log', 'debug', text);
  };
  var emitWarningLog = function (text) {
    _this.emit('log', 'warning', text);
  };
  var emitErrorLog = function (text) {
    _this.emit('log', 'error', text);
  };
  var emitSpecialLog = function (text) {
    _this.emit('log', 'special', text);
  };

  var lastBlockNotify = 0;

  if (!(options.coin.algorithm in algos)) {
    emitErrorLog('The ' + options.coin.algorithm + ' hashing algorithm is not supported.');
    throw new Error();
  }

  //this.apiClient = new APIClient("8.9.31.244");

  this.start = function () {
    SetupVarDiff();
    //SetupApi();
    SetupDaemonInterface(function () {
      DetectCoinData(function () {
        //SetupRecipients();
        SetupJobManager();
        OnBlockchainSynced(function () {
          //GetFirstJob(function() {
          SetupCutPolling();
          SetupGBTBlockPolling();
          SetupBlockPolling();
          //SetupPeer();
          StartStratumServer(function () {
            OutputPoolInfo();
            _this.emit('started');
          });
        });
        // });
      });
    });
  };


  // Make a bunch of calls to public cut api's polling to add additional invalidation 
  function SetupCutPolling() {
    if (typeof options.blockRefreshInterval !== 'number' || options.blockRefreshInterval <= 0) {
      emitLog('Block template polling has been disabled');
      return;
    }

    var pollingInterval = options.blockRefreshInterval;
    //let nodeCounter = 0;


    blockPollingIntervalId = setInterval(function () {
      let node = cutNodes[cutCounter];
      //console.log(`node ${node}`);
      let cutOptions = {
        url: `https://${node}${cutPath}`
      };

      reqfast(cutOptions, function (err, resp) {
        if (err) {
          console.log(`error ${node}: ${err}`);
        } else if (resp) {
          const hashes = resp.body.hashes;
          for (let i = 0; i < CHAINS; i++) {
            let job = _this.jobManager.getJobByChainId(i);
            if (job) {
              if (job.height <= hashes[i].height) {
                //console.log(chalk.red(`${Date.now()} USING CUT ${node} TO INVALIDATE chainId ${i} ${job.height}`))
                invalidateChainAndBroadcast(i);

                GetBlockTemplate(0, function (error, result) {
                  if (error) {
                    console.log(`ERROR IN GBT`);
                  }
                });
              }
            }
          }
        }
      });
      cutCounter = (cutCounter + 1) % cutNodes.length;
    }, 150);
  }


  function OutputPoolInfo() {
    var startMessage = 'Stratum Pool Server Started for ' + options.coin.name + ' [' + options.coin.symbol.toUpperCase() + '] {' + options.coin.algorithm + '}';
    if (process.env.forkId && process.env.forkId !== '0') {
      emitLog(startMessage);
      return;
    }
    //let height = _this.apiClient.getHeight();
    //let peers = _this.apiClient.getPeerCount();


    var infoLines = [
      startMessage,
      //"Current Block Height:\t" + height,
      //"Current Connect Peers:\t" + peers,
      //"Current Block Diff:\t" + "tbd",
      //_this.jobManager.currentJob.difficulty *
      //  algos[options.coin.algorithm].multiplier,
      //"Network Difficulty:\t" + options.initStats.difficulty,
      //"Network Hash Rate:\t" +
      //  util.getReadableHashRateString(options.initStats.networkHashRate),
      'Stratum Port(s):\t' + _this.options.initStats.stratumPorts.join(', '),
    ];

    if (typeof options.blockRefreshInterval === 'number' && options.blockRefreshInterval > 0)
      infoLines.push(`Work polling:\t\t${options.blockRefreshInterval}ms on ${nodes.length} nodes`);

    infoLines.push(`Stratum ID:\t\t${options.stratum_id}`)
    emitSpecialLog(infoLines.join('\n\t\t\t'));
  }

  function OnBlockchainSynced(syncedCallback) {
    // todo
    //console.log(`onBlockChainSynced`);

    // var checkSynced = function (displayNotSynced) {
    //   if (!process.env.forkId || process.env.forkId === '0') generateProgress();

    //   // todo for now assume we are synched
    // };
    // checkSynced(function () {
    //   //Only let the first fork show synced status or the log wil look flooded with it
    //   if (!process.env.forkId || process.env.forkId === '0')
    //     emitErrorLog('Daemon is still syncing with network (download blockchain) - server will be started once synced');
    // });

    syncedCallback();
  }
  // var generateProgress = function () {
  //   // console.log('generateProgress');
  // };

  // function SetupApi() {
  //   if (typeof options.api !== 'object' || typeof options.api.start !== 'function') {
  //     return;
  //   } else {
  //     options.api.start(_this);
  //   }
  // }

  // function SetupPeer() {
  //   if (!options.p2p || !options.p2p.enabled) return;

  //   if (options.testnet && !options.coin.peerMagicTestnet) {
  //     emitErrorLog('p2p cannot be enabled in testnet without peerMagicTestnet set in coin configuration');
  //     return;
  //   } else if (!options.coin.peerMagic) {
  //     emitErrorLog('p2p cannot be enabled without peerMagic set in coin configuration');
  //     return;
  //   }

  //   _this.peer = new peer(options);
  //   _this.peer
  //     .on('connected', function () {
  //       emitLog('p2p connection successful');
  //     })
  //     .on('connectionRejected', function () {
  //       emitErrorLog('p2p connection failed - likely incorrect p2p magic value');
  //     })
  //     .on('disconnected', function () {
  //       emitWarningLog('p2p peer node disconnected - attempting reconnection...');
  //     })
  //     .on('connectionFailed', function (e) {
  //       emitErrorLog('p2p connection failed - likely incorrect host or port');
  //     })
  //     .on('socketError', function (e) {
  //       emitErrorLog('p2p had a socket error ' + JSON.stringify(e));
  //     })
  //     .on('error', function (msg) {
  //       emitWarningLog('p2p had an error ' + msg);
  //     })
  //     .on('blockFound', function (hash) {
  //       _this.processBlockNotify(hash, 'p2p');
  //     });
  // }

  function SetupVarDiff() {
    //console.log("SetVarDiff()");
    _this.varDiff = {};
    Object.keys(options.ports).forEach(function (port) {
      if (options.ports[port].varDiff) _this.setVarDiff(port, options.ports[port].varDiff);
    });
  }

  /*
      Coin daemons either use submitblock or get_block_template for submitting new blocks
       */
  function SubmitBlock(blockHex) {

    if (blockHex == null) {
      console.log("*************** Submit with no blockHex!!");
      return;
    }
    //let endpoints = [process.env.SOLVED];
    //let endpoints = ['https://kadena2.icemining.ca/chainweb/0.0/mainnet01/mining/solved', 'https://kadena3.icemining.ca/chainweb/0.0/mainnet01/mining/solved'];
    //blockHex['stratum_id'] = _this.options.stratum_id;
    //console.log(chalk.blue(`SUBMITTING BblockHex ${JSON.stringify(blockHex)} powHeader ${blockHex.powHeader}`));

    let options = {
      method: 'POST',
      url: '',
      headers: {
        'Content-Type': 'application/octet-stream',
      },
      body: Buffer.from(blockHex.powHeader, 'hex'), //Buffer.from(blockHex.powHeader, "hex")
    };

    //options.url = endpoints[0]
    //for (let endpoint of endpoints) {
    try {
      //console.log(`submitting options ${JSON.stringify(options)}`);
      let port = 1848;
      options.url = 'http://' + nodes[blockHex.nodeIndex].hostname + ':' + port + process.env.SOLVED;
      //console.log(`submitting options ${JSON.stringify(options)} url is ${options.url} blockHex ${JSON.stringify(blockHex)}`);

      request(
        options,
        function (error, response, body) {
          if (!response || response.statusCode != 200) {
            console.log(chalk.red(`ERROR SUBMITTING TO NODE ${JSON.stringify(response)} body ${body}`));
            global.Sentry.captureException(error);
          }
          if (error) {
            global.Sentry.captureException(error);
          }
          //console.log(chalk`{greenBright Submitted ${blockHex.height}} returned ${response.statusCode}`);
        }.bind(this),
      );
    } catch (e) {
      console.log(`SOLVED ERROR! ${JSON.stringify(e.message)}`);
      global.Sentry.captureException(e);
    }

    //let chainId = util.getChainId(blockHex.chainId);
    //console.log("invalidate chainId " + blockHex.client.chainId);
    invalidateChainAndBroadcast(blockHex.client.chainId);

    //});

    /*
        console.log(
          colors.rainbow(`
    ______  ______  _____                   ____             _____   ______   _______
    \\     \\|\\     \\|\\    \\              ____\\_  \\__     _____\\    \\_|\\     \\  \\      \\
    |     |\|     | \\\\    \\            /     /     \\   /     /|     |\\\\     \\  |     /|
    |     |/____ /  \\\\    \\          /     /\\      | /     / /____/| \\|     |/     //
    |     |\\     \\   \\|    | ______ |     |  |     ||     | |____|/   |     |_____//
    |     | |     |   |    |/      \\|     |  |     ||     |  _____    |     |\\     \\
    |     | |     |   /            ||     | /     /||\\     \\|\\    \\  /     /|\\|     |
    /_____/|/_____/|  /_____/\\_____/||\\    \\_____/ || \\_____ \\|    | /_____/ |/_____/|
    |    |||     | | |      | |    ||| \\_____\\   | / | |     /____/||     | / |    | |
    |____|/|_____|/  |______|/|____|/ \\ |    |___|/   \\|_____|    |||_____|/  |____|/
                                     \\|____|               |____|/
    
    `)
        );
        console.log(
          "                                 Height: " +
          //_this.jobManager.currentJob.rpcData.number +
          "\n"
        );
    
        //emitLog('Submitted Block using ' + rpcCommand + ' successfully to daemon instance(s)');
      });
      */
  }

  function SetupRecipients() {
    var recipients = [];
    options.feePercent = 0;
    options.rewardRecipients = options.rewardRecipients || {};
    for (var r in options.rewardRecipients) {
      var percent = options.rewardRecipients[r];
      var rObj = {
        percent: percent / 50,
      };
      try {
        if (r.length === 40) rObj.script = util.miningKeyToScript(r);
        else rObj.script = util.addressToScript(r);
        recipients.push(rObj);
        options.feePercent += percent;
      } catch (e) {
        emitErrorLog('Error generating transaction output script for ' + r + ' in rewardRecipients');
      }
    }
    if (recipients.length === 0) {
      emitErrorLog('No rewardRecipients have been setup which means no fees will be taken');
    }
    options.recipients = recipients;
  }

  function SetupJobManager() {
    // One jobManager per chain
    _this.jobManager = new jobManager(options);
    _this.jobManager
      //.on("newBlock", function() {
      .on('newBlock', function (blockTemplate) {
        if (_this.stratumServer) {
          _this.stratumServer.broadcastMiningJobs(blockTemplate.chainId, _this.jobManager);
        }
      })
      .on('share', function (shareData, blockHex) {
        var isValidShare = !shareData.error;
        var isValidBlock = !!blockHex;
        shareData['stratum_id'] = options.stratum_id;

        var emitShare = function () {
          //console.log(`EMIT SHARE`);
          _this.emit('share', isValidShare, isValidBlock, shareData);
        };

        /*
          If we calculated that the block solution was found,
          before we emit the share, lets submit the block,
          then check if it was accepted using RPC getblock
          */
        //if (!isValidBlock) emitShare();
        if (isValidBlock) {
          SubmitBlock(blockHex);
          //  console.log(`err: ${err} res:${res}`);
          //});
        }
        emitShare();
      })
      .on('log', function (severity, message) {
        _this.emit('log', severity, message);
      });
  }

  function SetupDaemonInterface(finishedCallback) {
    if (!Array.isArray(options.daemons) || options.daemons.length < 1) {
      emitErrorLog('No daemons have been configured - pool cannot start');
      return;
    }

    //let height = _this.apiClient.getHeight();
    //let peers = _this.apiClient.getPeerCount();

    options.initStats = {
      //connections: peers
      //difficulty: difficulty
      //networkHashRate: rpcResults.getmininginfo.networkhashps
    };

    // _this.emit("log", severity, message);
    //});

    finishedCallback();
  }

  function DetectCoinData(finishedCallback) {
    //console.log(`detect coin data`);

    //_this.apiClient.getDifficulty();

    //      options.protocolVersion = options.coin.hasGetInfo ? rpcResults.getinfo.protocolversion : rpcResults.getnetworkinfo.protocolversion;
    //var difficulty = rpcResults.compact_target;
    //let peers = _this.apiClient.getPeerCount();
    options.initStats = {
      //connections: peers
      //difficulty: difficulty
      //networkHashRate: rpcResults.getmininginfo.networkhashps
    };

    options.hasSubmitMethod = true;
    finishedCallback();
    //});
  }

  function StartStratumServer(finishedCallback) {
    console.log(`StartStratumServer`);
    _this.stratumServer = new stratum.Server(options, authorizeFn);
    _this.stratumServer
      .on('started', function () {
        //console.log('started just happened');

        options.initStats.stratumPorts = Object.keys(options.ports);
        finishedCallback();
      })
      .on('broadcastTimeout', function () {
        emitLog('No new blocks for ' + options.jobRebroadcastTimeout + ' seconds - restart cut listeners?');
      })
      .on('client.connected', function (client) {
        if (typeof _this.varDiff[client.socket.localPort] !== 'undefined') {
          //GDT TODO dont manage d=XX static diffs?
          _this.varDiff[client.socket.localPort].manageClient(client);
        } else {
          ;//console.log('**** NOT vardiff managed');
        }
        // CLIENT!!!!
        client
          .on('clientReady', function (client) {
            //console.log(`clientReady. client=${JSON.stringify(client)}`)
            // Send a random valid mining job right away
            //console.log(`START SEND JOB?`);
            let randChainId = Math.floor(Math.random(CHAINS) * CHAINS);
            const firstJob = _this.jobManager.getNextAvailableJob(randChainId);
            if (!firstJob) {
              console.log(`no first job`);
              return;
            }
            client.chainId = firstJob.chainId;
            client.sendMiningJob(firstJob);
          })
          .on('difficultyChanged', function (diff) {
            _this.emit('difficultyUpdate', client.workerName, diff, client.iceWorkerId);
            // console.log(
            //  "pool.js  on difficultyChanged event. Emitting difficultyUpdate " +
            //   diff
            //);
          })
          .on('subscription', function (params, resultCallback) {
            resultCallback(null, true);
          })
          .on('submit', function (params, resultCallback) {
            //console.log("onSubmit params:" + JSON.stringify(params) + "client chainId is" + client.chainId);

            var result = _this.jobManager.processShare(
              client,
              params.jobId,
              client.previousDifficulty,
              client.difficulty,
              client.noncePrefix,
              params.nonce,
              client.remoteAddress,
              client.socket.localPort,
              params.name,
              client.iceWorkerId,
              client.iceUserId,
              client.iceCoinId,
            );
            //console.log("result:" + JSON.stringify(result));
            resultCallback(result.error, result.result ? true : null);
          })
          .on('malformedMessage', function (message) {
            emitWarningLog('Malformed message from ' + client.getLabel() + ': ' + message);
          })
          .on('socketError', function (err) {
            emitWarningLog('Socket error from ' + client.getLabel() + ': ' + JSON.stringify(err));
          })
          .on('socketTimeout', function (reason) {
            //emitWarningLog('Connected timed out for ' + client.getLabel() + ': ' + reason)
          })
          .on('socketDisconnect', function (iceWorkerId, workerName, uuid) {
            _this.emit('minerDisconnect', iceWorkerId, workerName, uuid);
            //emitLog('Socket disconnected from ' + client.getLabel());
          })
          .on('kickedBannedIP', function (remainingBanTime) {
            emitLog('Rejected incoming connection from ' + client.remoteAddress + ' banned for ' + remainingBanTime + ' more seconds');
          })
          .on('forgaveBannedIP', function () {
            emitLog('Forgave banned IP ' + client.remoteAddress);
          })
          .on('unknownStratumMethod', function (fullMessage) { })
          .on('socketFlooded', function () {
            emitWarningLog('Detected socket flooding from ' + client.getLabel());
          })
          .on('tcpProxyError', function (data) {
            // emitErrorLog('Client IP detection failed, tcpProxyProtocol is enabled yet did not receive proxy protocol message, instead got data: ' + data);
          })
          .on('bootedBannedWorker', function () {
            emitWarningLog('Booted worker ' + client.getLabel() + ' who was connected from an IP address that was just banned');
          })
          .on('triggerBan', function (reason) {
            emitWarningLog('Banned triggered for ' + client.getLabel() + ': ' + reason);
            _this.emit('banIP', client.remoteAddress, client.workerName);
          });
      });
  }


  // Called when a block is solved, or a new Cut is received indicating the work is invalid
  // TODO hit the lowest diff with more miners than highest diff block
  function invalidateChainAndBroadcast(chainId) {
    //console.log(`invalidateChainAndBroadcast(${chainId})`);
    if (_this.jobManager.getJobByChainId(chainId) === null) {
      //console.log("NO JOB IN INVALIDATE");
      return;
    }
    
    _this.jobManager.deleteJobByChainId(chainId);
    var stratumClients = _this.stratumServer.getStratumClients();
    var keys = Object.keys(stratumClients);

    for (var i = 0; i < keys.length; i++) {
      let nextJob = _this.jobManager.getNextAvailableJob();
      let c = stratumClients[keys[i]];

      if (nextJob === null) {
        c.chainId = null; // still nothing useful to do
        return;
      } else {
        //console.log(`nextJob chainId ${nextJob.chainId}`);
        if (c.chainId === null) {
          c.chainId = nextJob.chainId;
          c.sendMiningJob(nextJob);
          return;
        } else if (c.chainId == chainId) {
          c.chainId = nextJob.chainId;
          c.sendMiningJob(nextJob);
        }
      }
    }
  }

  function retriableRequest(chainBytes, options, chainId, nodeIndex) {
    //console.log("retriableRequest nodeIndex " + nodeIndex);
    //console.log(`retriableRequest 4 args: ${chainBytes} ${options} ${chainId} ${nodeIndex}`);
    //console.log(`retriableRequest -> chain: ${chainId} , node: ${nodeIndex}`);

    const req = http.request(options, res => {
      //console.log(`headers: ${res.headers}`);

      if (res.statusCode != 200) {
        console.log(`statusCode: ${res.statusCode}`);
        return;
      }
      res.on('data', d => {
        //console.log(chalk.blue(`${Date.now()} USING MINING/UPDATES TO INVALIDATE chainId ${chainId}`));

        // todo: dont add stale work
        invalidateChainAndBroadcast(chainId);

        //console.log(chalk.green(`new Cut node ${nodeIndex} on chainId ${chainId}.. will call mining/work?chainid=${chainId}...`));
        //console.log(`about to call GBT from retriableRequest`);
        GetBlockTemplate(nodeIndex, function (error, result) {
          if (error) {
            console.log(`ERROR IN GBT`);
          }
          // if (result) {
          //   console.log(`GBT RESULT ${result}`);
          // }
        });
      });
    });
    // req.setTimeout(15000, ()=>{
    //   req.abort()

    // })
    req.on('timeout', () => {
      console.log(`${chainId} timed out on node ${nodeIndex}`);
      req.abort();
      retriableRequest(chainBytes, options, chainId, nodeIndex);
    });
    req.on('error', error => {
      console.log(chalk.yellow(`chainId: ${chainId}, error: ${error.code}`));
      //req.removeAllListeners();

      // if (error.code === 'ECONNRESET') {
      //console.log(`resetting nodeIndex ${nodeIndex}`);
      retriableRequest(chainBytes, options, chainId, nodeIndex);
      // }
      // MARK: How to auto-reconnect this (it should match the right node index)
    });

    req.write(chainBytes[chainId]);
  }

  function SetupGBTBlockPolling() {
    if (typeof options.blockRefreshInterval !== 'number' || options.blockRefreshInterval <= 0) {
      emitLog('Block template polling has been disabled');
      return;
    }

    var pollingInterval = options.blockRefreshInterval;

    blockPollingIntervalId = setInterval(function () {
      //nodeCounter++;

      for (let node of nodes) {
        //console.log("calling GBT Polling on nodeIdx " + node.nodeIndex);
        //options.hostname = node.hostname;
        GetBlockTemplate(node.nodeIndex, function (error, result) {
          if (error) {
            global.Sentry.captureException(`GBT Error: ${error}`);
            console.log(`ERROR IN GBT`);
          }
        });
      }
      // invalidateChainAndBroadcast();
    }, pollingInterval);
  }

  function SetupBlockPolling() {
    //console.log(`Work poll ${options.blockRefreshInterval}ms on ${nodes.length} nodes`);

    let chainBytes = [
      Buffer.from('00000000', 'hex'),
      Buffer.from('01000000', 'hex'),
      Buffer.from('02000000', 'hex'),
      Buffer.from('03000000', 'hex'),
      Buffer.from('04000000', 'hex'),
      Buffer.from('05000000', 'hex'),
      Buffer.from('06000000', 'hex'),
      Buffer.from('07000000', 'hex'),
      Buffer.from('08000000', 'hex'),
      Buffer.from('09000000', 'hex'),
      Buffer.from('0a000000', 'hex'), // 10
      Buffer.from('0b000000', 'hex'), // 11
      Buffer.from('0c000000', 'hex'), // 12
      Buffer.from('0d000000', 'hex'), // 13
      Buffer.from('0e000000', 'hex'), // 14
      Buffer.from('0f000000', 'hex'), // 15
      Buffer.from('10000000', 'hex'), // 16
      Buffer.from('11000000', 'hex'), // 17
      Buffer.from('12000000', 'hex'), // 18
      Buffer.from('13000000', 'hex'), // 19
    ];

    const options = {
      //hostname: 'test.icemining.ca',
      //hostname: hostnames[nodeIndex],
      port: 1848,
      timeout: 300000,
      path: `/chainweb/0.0/${process.env.NODE_NET}/mining/updates`,
      method: 'GET',
      headers: {
        //'Content-Type': 'text/event-stream',
        'Accept': 'text/event-stream',
        'Cache-Control': 'no-cache',
        'Connection': 'keep-alive',
        //"Content-Type": "application/json",
        'Content-Type': 'application/octet-stream',
        'content-length': 4,
      },
    };
    //options.agent = new https.Agent({ keepAlive: true });

    for (let node of nodes) {
      options.hostname = node.hostname;
      //console.log(options);
      for (let chainId = 0; chainId < CHAINS; chainId++) {
        retriableRequest(chainBytes, options, chainId, node.nodeIndex);
      }
    }
  }

  /*
    ["chainId" "jobId", "header hash", height, cleanJob]
    */
  function GetBlockTemplate(nodeIndex, callback) {
    if (nodeIndex === undefined) {
      console.log(chalk.red(`GBT undefined nodeIndex, returning...`));
      return;
    }
    const nodeId = nodes[nodeIndex].id;

    //console.log(`GBT first args: ${chainId} ${nodeIndex}`);
    //    console.log(
    //     `GBT (calling mining/work) chainId ${chainId} nodeIndex ${nodeIndex} nodeId ${nodeId} endpoint - hostname: ${nodes[nodeIndex].hostname}`
    // );

    const js = JSON.stringify({
      'account': process.env.PUBKEY,
      'predicate': 'keys-all',
      'public-keys': [process.env.PUBKEY],
    });

    let path = process.env.WORK;//+ '?chain=' + chainId;

    const options = {
      hostname: nodes[nodeIndex].hostname,
      port: 1848,
      timeout: 1000,
      path: path, //"/chainweb/0.0/testnet04/mining/work",
      method: 'GET',
      headers: {
        'accept': 'application/octet-stream',
        'content-type': 'application/json',
        'content-length': js.length,
      },
    };

    const req = http.request(options, res => {
      //console.log(`statusCode: ${res.statusCode}`);
      if (res.statusCode != 200) {
        global.Sentry.captureException(`Error getting work from node: ${res.statusCode}`);
        return;
      }
      res.on('data', d => {
        let rpcData = Buffer.from(d, 'binary').toString('hex');
        // Get the chainId
        //const chainId = util.getChainId(rpcData);
        //const height = util.getHeight(rpcData);
        //  if (chainId < 0 || chainId > 10) {
        //    console.log(chalk.red(`raw data ${d}`));
        //    console.log(chalk.red(`*** dadta: ${rpcData}`));
        //   global.Sentry.captureException(`SHOULD NOT HIT THIS. Error getting work from node: ${res.statusCode}`);
        //  }
        //console.log(chalk.blue(`GBT node ${nodeIndex} chainId ${chainId} height ${height}`));
        // Broadcast on the deleted job
        _this.jobManager.processTemplate(rpcData, nodeIndex, nodeId);
        callback(null, {}, rpcData);
      });
    });
    req.on('error', error => {
      //global.Sentry.captureException(`GBT request error: ${error}`);
      console.error(error);
    });
    req.write(js);
    req.end();
    // }
  }

  this.relinquishMiners = function (filterFn, resultCback) {
    var origStratumClients = this.stratumServer.getStratumClients();

    var stratumClients = [];
    Object.keys(origStratumClients).forEach(function (subId) {
      stratumClients.push({ subId: subId, client: origStratumClients[subId] });
    });
    async.filter(stratumClients, filterFn, function (clientsToRelinquish) {
      clientsToRelinquish.forEach(function (cObj) {
        cObj.client.removeAllListeners();
        _this.stratumServer.removeStratumClientBySubId(cObj.subId);
      });

      process.nextTick(function () {
        resultCback(
          clientsToRelinquish.map(function (item) {
            return item.client;
          }),
        );
      });
    });
  };

  this.attachMiners = function (miners) {
    console.log(`ATTACH MINERS`);
    miners.forEach(function (clientObj) {
      _this.stratumServer.manuallyAddStratumClient(clientObj);
    });

    //for (let chainId = 0; chainid < 10; chainId++)
    //  _this.stratumServer.broadcastMiningJobs(
    // );
  };

  this.getStratumServer = function () {
    return _this.stratumServer;
  };

  // gdt todo?
  //this.getJobManager = function() {
  //  return _this.stratumServer.getJobManager(_this.jobManager);
  //};

  this.setVarDiff = function (port, varDiffConfig) {
    console.log('setVardiff');

    if (typeof _this.varDiff[port] != 'undefined') {
      _this.varDiff[port].removeAllListeners();
    }
    var varDiffInstance = new varDiff(port, varDiffConfig);
    _this.varDiff[port] = varDiffInstance;
    _this.varDiff[port].on('newDifficulty', function (client, newDiff) {
      /* We request to set the newDiff @ the next difficulty retarget
             (which should happen when a new job comes in - AKA BLOCK) */
      client.enqueueNextDifficulty(newDiff);

      //_this.stratumServer.getSPS();
      //console.log(`Difficulty Change: ${client.previousDifficulty} -> ${newDiff} valid shares: ${client.shares.valid} invalid: ${client.shares.invalid}`);
    });
  };

  this.getTotalMinerCount = function () {
    return _this.stratumServer.getTotalMinerCount();
  };
});
pool.prototype.__proto__ = events.EventEmitter.prototype;

