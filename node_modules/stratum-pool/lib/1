//var njstrace = require('njstrace').inject();
var chalk = require('chalk');
var blake2 = require('blake2');

var events = require('events');
var crypto = require('crypto');

var util = require('./util.js');
var blockTemplate = require('./blockTemplate.js');

var u2 = require('util');
//var sentry;

const CHAINS = 20;

BigInt.prototype.toJSON = function () {
  return this.toString();
};


//Unique jobid per new block template
var JobCounter = function () {
  var counter = 0;
  this.next = function () {
    counter++;
    if (counter % 0xffffff === 0) counter = 0;
    return this.cur();
  };

  this.cur = function () {
    //console.log("******* current job Counter:" + counter.toString(16));
    return counter.toString(16);
  };
};

/**s
 * Emits:
 * - newBlock(blockTemplate) - When a new block (previously unknown to the JobManager) is added, use this event to broadcast new jobs
 * - share(shareData, blockHex) - When a worker submits a share. It will have blockHex if a block was found
 **/
var JobManager = (module.exports = function JobManager(options) {
  //private members
  var _this = this;

  var jobCounter = new JobCounter();


  this.currentJob = [];
  this.curHeights = {};
  for (let i = 0; i < CHAINS; i++) this.curHeights[i] = 0;

  this.lastHeightChange = Date.now() / 1000;
  this.randomCounter = 0;

  // Change: We will accept from multiple nodes, so there will be races. Only accept the real change
  // by comparing to prevJobs and updating accordingly
  this.processTemplate = function (rpcData, nodeIndex, nodeId) {
    const chainId = util.getChainId(rpcData);
    const rpcHeight = util.getHeight(rpcData);

    if (rpcHeight > this.curHeights[chainId]) {
      this.lastHeightChange = Math.floor(Date.now() / 1000);
      //console.log(chalk.rgb(255, 0, 255)(`${this.curHeights[rpcChainId]} -> ${rpcHeight} updated at ${this.lastHeightChange}`));
      this.curHeights[chainId] = rpcHeight;

      // Add the job
      const tmpBlockTemplate = new blockTemplate(jobCounter.next(), rpcData, nodeIndex, nodeId);
      this.addJob(tmpBlockTemplate);

    } else {
      let now = Date.now() / 1000;
      if (now - this.lastHeightChange > 60) {
        console.log(chalk.red(`FORK DETECTED !!!`));
        global.Sentry.captureException(`FORK DETECTED. STUCK ON HEIGHT ${this.curHeight} for a bit`);
      }
      return;
    }

    //this.printJobs();
  };

  this.printJobs = function () {
    //console.log(`printJobs currentJob.length: ${_this.currentJob.length}`);
    for (let i = 0; i < _this.currentJob.length; i++) {
      let output;
      let job = _this.currentJob[i];
      if (job !== null) output = chalk.gray(job.chainId + ':') + chalk.yellow(`${job.jobId.toString('hex')}(${job.height}) `);
      //else output = chalk.gray(job.chainId + ":-- ");
      process.stdout.write(chalk.rgb(255, 0, 255)(output));
    }
    process.stdout.write('\n');
  };

  this.getJobHeightByChain = function (chainId) {
    let job = _this.getJobByChainId(chainId);
    if (job) {
      const height = util.getHeight(job.rpcData);
      console.log(`height ${height}`);
    }
  };

  // this.getInvalidatedJobByChainId = function (chainId) {
  //   //console.log(chalk.red(`getJobByChainId ${chainId} length ${chainId} ${u2.inspect(_this.currentJob)}`));
  //   for (let i = 0; i < _this.invaliJob.length; i++) {
  //     let job = _this.previousJob[i];
  //     if (job !== null && job.chainId == chainId) return job;
  //   }

  //   return null;
  // };

  this.getJobByChainId = function (chainId) {
    //console.log(chalk.red(`getJobByChainId ${chainId} length ${chainId} ${u2.inspect(_this.currentJob)}`));
    for (let i = 0; i < _this.currentJob.length; i++) {
      let job = _this.currentJob[i];
      if (job !== null && job.chainId == chainId) return job;
    }

    return null;
  };

  // Also adds to invalidatedJobs to prevent re-adding the same work after being invalidated by cut, but work node doesn't 
  // yet have new work on that chainid
  this.addJob = function (job) {
    //console.log(chalk.gray(`addJob. job.height ${job.height} job.chainId: ${job.chainId}`));

    // Do we have a job on this chainid?
    const curjob = this.getJobByChainId(job.chainId);

    // Don't add duplicate work
    if (curjob !== null && job.height <= curjob.height) {
      //console.log("skipping duplicate job height " + job.height + " chainid " + job.chainId);
      return null;
    }

    this.currentJob.push(job);
    //console.log("+job: height " + job.height + " chainid " + job.chainId)
    return job;
  };

  this.getJobByJobId = function (jobId) {
    for (let i = 0; i < this.currentJob.length; i++) {
      let job = this.currentJob[i];
      if (job !== null && job.jobId == jobId) return job;
    }
    //console.log(chalk.red(`***** NO AVAILABLE JOBS.trying to get jobid ${ jobId }`));
    //global.Sentry.captureException("KDA Stratum: No available jobs!");
  };

  this.deleteJobByChainId = function (chainId) {
    //console.log("deleteJobByChainId chainid " + chainId)
    for (let i = 0; i < this.currentJob.length; i++) {
      let job = this.currentJob[i];
      if (job !== null && job.chainId == chainId) {
        //console.log(chalk.red(`deleteJob on chain ${chainId} which is jobId ${job.jobId}`));
        this.currentJob.splice(i, 1);
      }
    }
    //console.log(`after delete chainId ${ chainId } `);
    this.printJobs();
  };

  // todo: sort by diff, spread by top 4 id's

  // This will ensure any current job on chainId is "mineable" based on diGraph requirements
  // this.updateJobs = function (chainId) {
  //   console.log(`TODO updateJobs()`);

  // }
  this.getNextAvailableJob = function () {
    //this.printJobs();
    if (this.currentJob.length == 0) {
      console.log(chalk.red(`NO JOBS!!!! RETURN NULL`));
      return null;
    }
    // else if (this.currentJob.length == 1) {
    //     return this.currentJob[0];
    // }

    let nextJob = null;
    do {
      nextJob = this.getJobByChainId(this.randomCounter);
      this.randomCounter = (this.randomCounter + 1) % 20; //this.currentJob.length;
    } while (nextJob === null);

    return nextJob;
  };

  /*
  // test1: spread to all chains evenly.. increment a counter here
  this.getNextAvailableJob = function() {
    if (this.currentJob.length <= 1) {
      //console.log(chalk.red(`NO JOBS!!!! RETURN NULL`));
      return null;
    }
    let nextJob = null;
    let nextId = Math.floor(Math.random(10) * 10);
    do {
      nextId = Math.floor(Math.random(10) * 10);
      nextJob = this.getJobByChainId(nextId);
    } while (nextJob === null);
   
    return this.getJobByChainId(nextId);
  };
  */

  // processShare() jobId:5 prevDif:null diff:10000000000 en2:154764bb49 ip:::ffff:87.78.81.5 port:3700 worker:ac897c207d88bcc71d9775fa928864e922db0a391bc0b2885bb630b8fc97d551.TTMiner_Dev workerid:103312410 userid:44382 coinid:2420
  this.processShare = function (
    client,
    jobId,
    previousDifficulty,
    difficulty,
    noncePrefix,
    nonce,
    ipAddress,
    port,
    workerName,
    iceWorkerId,
    iceUserId,
    iceCoinId,
  ) {
    //console.log("share f1:" + client.f1);
    //console.log("current | prev Jobs: " + _this.currentJob.length + " | " + _this.previousJob.length + " noncePrefix:" + noncePrefix);

    var shareError = function (error) {
      console.log("share error: " + error);
      //_this.emit('share', {
      //  job: jobId,
      //  ip: ipAddress,
      //  worker: workerName,
      /*difficulty: difficulty,*/
      //  error: error[1],
      //});
      //if (Math.random(10) < 4)
      return { error: error, result: null };
      // else
      //   return { result: true, error: null };

    };

    //prevDif:${previousDifficulty} diff:${difficulty oncePrefix ${ noncePrefix } nonce: ${ nonce }
    //var job = this.validJobs[jobId];
    let job = this.getJobByJobId(jobId); //this.currentJob[client]
    //client.chainId = job.chainId;
    //let nextJob = getNextAvailableJob(job.chainId);
    //client.chainId
    //client.sendMiningJob(this.getNextAvailableJob());

    if (!job) {
      //console.log(chalk.red(`STALE JOB (EXPECTED ONCE). not returning error`));
      return shareError([20, `job not found: id ${jobId}`, null]);
    }
    if (job.jobId != jobId) {
      console.log(chalk.red(`MISSING  JOB ${jobId} for client on chainId ${client.chainId} ${workerName}`));
      // return shareError([20, 'job not found', null]);
      //console.log("jobId not found... continuing...");
    }

    //if (typeof client.chainId === "undefined") {
    if (client.chainId === null) {
      //console.log(chalk.red(`CHAIN ID MISSING. job ${job.chainId}`));
      //client.chainId = 0;
      client.chainId = job.chainId;
    }

    //if (nonce.length != 11) {
    nonce = util.padLeftHexString(nonce, 12);
    //return shareError([21, 'invalid solution', null]);
    //}


    if (!job.registerSubmit(nonce)) {
      console.log(`Duplicate share from ${workerName} ${iceUserId} ${iceWorkerId} ${ipAddress}`);
      return shareError([22, 'duplicate share', null]);
    }

    //const diff1 = BigInt('0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff');

    const blockTgt = job.blockTgt;
    const blockDiff = util.target_to_diff(blockTgt);
    if (client.f1) {
      nonce = util.reverseHex(nonce);
      noncePrefix = util.reverseHex(noncePrefix);
    }

    fullNonce = util.reverseHex(nonce + noncePrefix); // no
    //console.log(`DEBUG nonce ${nonce} noncePrefix ${noncePrefix}`)
    //console.log(`DEBUG fullNonce is ${fullNonce} length ${fullNonce.length}`)
    let powHeaderHash = job.powHeader.substring(0, 556) + fullNonce;
    //console.log(`DEBUG powHeaderHash is ${powHeaderHash} length ${powHeaderHash.length}`)

    let blockHash, blockData = null;

    var h = blake2.createHash('blake2s');
    h.update(Buffer.from(powHeaderHash, 'hex'));
    let hash = util.padLeftHexString(util.reverseHex(h.digest('hex')), 64);
    //console.log(`blake2s ${hash} with input ${powHeaderHash}`);
    const hashInt = BigInt('0x' + hash);
    var shareDiff = util.target_to_diff(hashInt);
    //console.log("shareDiff: " + shareDiff + " difficulty: " + difficulty + "previousDiff: " + previousDifficulty + " blockDiff: " + blockDiff + " hash:" + hash)

    //difficulty = Math.floor(difficulty);
    //previousDifficulty = Math.floor(previousDifficulty);

    const height = job.height;
    const blockReward = util.getMinerReward(height);

    //if (shareDiff > 10000)
    //let diff = blockDiff - shareDiff;
    //let percent = 100/parseInt(blockDiff / shareDiff)
    /*
    console.log(
      "share diff " +
        chalk.rgb(105, 20, 105)(`${shareDiff}`) +
        " blockDiff " +
        blockDiff +
        " delta " +
        diff
    );
   
  */
    //Check if share is a block candidate (matched network difficulty)s
    if (shareDiff >= blockDiff) {
      //console.log("************* TRY TO SUBMIT ***********")
      blockData = {};
      blockData['powHeader'] = powHeaderHash;
      blockData['client'] = client;
      blockData['nonce'] = fullNonce;
      blockData['height'] = job.height;
      blockData['nodeIndex'] = job.nodeIndex;
      blockData['nodeId'] = job.nodeId;
      //blockData['duration'] = Date.now() - job.startTime;
      //blockData["hash"] = hash;

      console.log(chalk.green(`*** submitted ${job.height} id ${job.chainId}/${job.jobId} ${hash} nodeId ${job.nodeId}`));
    } else {
      if (shareDiff < difficulty) {
        console.log("shareDiff " + shareDiff + " difficulty " + difficulty);
        // Also check previousDiff for vardiff adjustments
        if (!previousDifficulty || (previousDifficulty && shareDiff < previousDifficulty)) {
          // console.log(
          //   "LOW DIFF SHARE! " +
          //     iceWorkerId +
          //     " prevDiff:" +
          //     previousDifficulty +
          //     " diff:" +
          //     difficulty +
          //     " shareDiff:" +
          //     shareDiff
          // );
          return shareError([23, 'Low Difficulty Share']);
        }
      }

    }

    let shareMode = 0;
    if (client.mode == "solo")
      shareMode = 1;
    else if (client.mode == "party")
      shareMode = 2;

    job.shareCount += BigInt(difficulty);
    //job.shareCount += BigInt(shareDiff);

    // console.log("shareDiff " + parseInt(shareDiff) + " difficulty " + parseInt(difficulty));

    _this.emit(
      'share',
      {
        job: jobId,
        ip: ipAddress,
        port: port,
        worker: workerName,
        height: job.height,
        blockReward: blockReward,
        difficulty: parseInt(difficulty),
        shareDiff: parseInt(shareDiff),
        blockDiff: blockDiff.toString(), //blockDiffAdjusted,
        blockDiffActual: parseInt(job.difficulty),
        blockHash: hash,
        blockHashInvalid: 0, //blockHashInvalid,
        iceWorkerId: iceWorkerId,
        iceUserId: iceUserId,
        iceCoinId: iceCoinId,
        chainId: job.chainId,
        node_id: job.nodeId,
        mode: shareMode,
        party_pass: client.party_pass,
        duration: Date.now() - job.startTime,
        shares: job.shareCount,
      },
      blockData,
    );

    return { result: true, error: null, blockHash: blockHash };
  };
});
JobManager.prototype.__proto__ = events.EventEmitter.prototype;
